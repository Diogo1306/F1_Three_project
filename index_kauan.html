<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Three js</title>
    <style>
      body {
        margin: 0;
      }

      .loader {
        width: fit-content;
        font-weight: bold;
        font-family: monospace;
        white-space: pre;
        font-size: 30px;
        line-height: 1.2em;
        height: 1.2em;
        overflow: hidden;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%);

        display: none;
      }

      .loader:before {
        content: "Loading...\A⌰oading...\A⌰⍜ading...\A⌰⍜⏃ding...\A⌰⍜⏃⎅ing...\A⌰⍜⏃⎅⟟ng...\A⌰⍜⏃⎅⟟⋏g...\A⌰⍜⏃⎅⟟⋏☌...\A⌰⍜⏃⎅⟟⋏☌⟒..\A⌰⍜⏃⎅⟟⋏☌⟒⏁.\A⌰⍜⏃⎅⟟⋏☌⟒⏁⋔";
        white-space: pre;
        display: inline-block;
        animation: l39 1s infinite steps(11) alternate;
      }

      @keyframes l39 {
        100% {
          transform: translateY(-100%);
        }
      }
    </style>
  </head>
  <body>
    <div class="loader"></div>
    <div id="tlContainer">
      <div id="timelines"></div>
    </div>
    <script>
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import {
        GLTFLoader,
        OBJLoader,
        FBXLoader,
        STLLoader,
        ColladaLoader,
        TDSLoader,
      } from "three/examples/jsm/Addons.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import * as CANNON from "cannon-es"; // ✅ Adicionado cannon-es
      import { max } from "three/tsl";

      // === GLOBAL VARS ===
      let mixer;
      let actions = {};
      let activeAction;
      let bikerModel;
      let keys = [];
      let moveSpeed = 0;
      const maxSpeed = 20;
      const acceleration = 0.1;
      const braking = 1;
      const clock = new THREE.Clock();
      let skeletonHelper;
      let collisionHelper;

      const floorY = -8.33;

      // === PHYSIC World (CANNON) ===
      const physicsWorld = new CANNON.World({
        gravity: new CANNON.Vec3(0, -9.82, 0),
      });
      let bikerBody;

      // === SCENE AND CAMERA ===
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xabbbd6);
      const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 500);
      camera.position.set(0, 10, 10);

      // === RENDERER ===
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      renderer.setAnimationLoop(loop);

      // === ORBIT CONTROLS ===
      const orbitControls = new OrbitControls(camera, renderer.domElement);
      orbitControls.enableDamping = true;
      orbitControls.enablePan = false;

      // === LIGHTS ===
      const params = {
        useDirLight: false,
        useAmbientLight: true,
        directionalLight: 1,
        showHelpers: false,
        skeletonHelper: false,
        showAxes: false,
        collisionHelper: false,
      };

      const ambientLight = new THREE.AmbientLight(0xffffff, 2);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(8, 50, 0);
      directionalLight.castShadow = true;
      directionalLight.shadow.bias = -0.00005;
      directionalLight.shadow.normalBias = 0.05;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 200;
      directionalLight.shadow.mapSize.set(1024, 1024);
      directionalLight.visible = false;
      scene.add(directionalLight);

      const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
      scene.add(lightHelper);
      lightHelper.visible = false;

      const helper = new THREE.CameraHelper(directionalLight.shadow.camera);
      scene.add(helper);
      helper.visible = false;

      // === FLOOR ===
      // const texturePlane = new THREE.TextureLoader().load("resources/images/basketball-court.jpg");
      // const normalMap = new THREE.TextureLoader().load("resources/images/basketball-court_normal.png");
      // const displacementMap = new THREE.TextureLoader().load("resources/images/basketball-court_displacement.png");

      // const planeGeometry = new THREE.PlaneGeometry(28, 15, 256, 256);
      // const planeMaterial = new THREE.MeshStandardMaterial({
      //   map: texturePlane,
      //   displacementMap: displacementMap,
      //   displacementScale: 0.5,
      //   normalMap: normalMap,
      //   metalness: 0.9,
      //   roughness: 0.1,
      //   side: THREE.DoubleSide,
      // });

      // const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      // plane.receiveShadow = true;
      // plane.rotation.x = -Math.PI / 2;
      // plane.position.y = 0;
      // scene.add(plane);

      // === CHANGE ANIMATIONS ===
      function playAnimation(name, loop = true) {
        if (!actions[name]) return;
        if (activeAction !== actions[name]) {
          if (activeAction) activeAction.fadeOut(0.2);
          activeAction = actions[name];
          activeAction.reset().fadeIn(0.2).play();
          activeAction.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce);
        }
      }

      function stopCurrentAnimation() {
        if (activeAction) {
          activeAction.fadeOut(0.2);
          activeAction.stop();
          activeAction = null;
        }
      }

      function createTrimesh(geometry) {
        if (!geometry.attributes.position) return null;

        const pos = geometry.attributes.position.array;
        const index = geometry.index ? geometry.index.array : Array.from({ length: pos.length / 3 }, (_, i) => i);

        const vertices = [];
        for (let i = 0; i < pos.length; i += 3) {
          vertices.push(new CANNON.Vec3(pos[i], pos[i + 1], pos[i + 2]));
        }

        const indices = [];
        for (let i = 0; i < index.length; i += 3) {
          indices.push([index[i], index[i + 1], index[i + 2]]);
        }

        return new CANNON.Trimesh(
          vertices.flatMap((v) => [v.x, v.y, v.z]),
          indices.flat()
        );
      }

      // === CREATE PANEL GUI ===
      function createPanel() {
        const gui = new GUI();

        const lightsFolder = gui.addFolder("Luzes");
        lightsFolder
          .add(params, "useDirLight")
          .name("Direcional Ligada")
          .onChange((v) => (directionalLight.visible = v));
        lightsFolder
          .add(params, "useAmbientLight")
          .name("Luz Ambiente Ligada")
          .onChange((v) => (ambientLight.visible = v));
        lightsFolder
          .add(params, "directionalLight", 1, 10.0, 0.1)
          .name("Intensidade Direcional")
          .onChange((v) => (directionalLight.intensity = v));

        const debugFolder = gui.addFolder("Debug");

        debugFolder
          .add(params, "showHelpers")
          .name("Light Helpers")
          .onChange((v) => {
            lightHelper.visible = v;
            helper.visible = v;
          });
        debugFolder
          .add(params, "skeletonHelper")
          .name("Skeleton Helper")
          .onChange((v) => {
            skeletonHelper.visible = v;
          });
        debugFolder
          .add(params, "collisionHelper")
          .name("Collisions")
          .onChange((v) => {
            collisionHelper.visible = v;
          });
      }

      // === LOAD MODELS ===
      function loadModel(url, position, rotation, scale, options = {}) {
        return new Promise((resolve, reject) => {
          const extension = url.split(".").pop().toLowerCase();
          let loader;

          switch (extension) {
            case "3ds":
              loader = new TDSLoader();
              break;
            case "obj":
              loader = new OBJLoader();
              break;
            case "stl":
              loader = new STLLoader();
              break;
            case "dae":
              loader = new ColladaLoader();
              break;
            case "fbx":
              loader = new FBXLoader();
              break;
            case "glb":
            case "gltf":
              loader = new GLTFLoader();
              break;
            default:
              console.warn("Formato não suportado:", extension);
              return reject();
          }

          loader.load(
            url,
            (model) => {
              const object = model.scene || model;
              object.position.set(position.x, position.y, position.z);
              object.rotation.set(rotation.x, rotation.y, rotation.z);
              object.scale.set(scale.x, scale.y, scale.z);

              object.traverse((child) => {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  if (child.material && child.material.side === undefined) {
                    child.material.side = THREE.DoubleSide;
                  }
                }
              });

              scene.add(object);

              if (extension === "fbx" && options.isCharacter) {
                mixer = new THREE.AnimationMixer(object);

                model.animations.forEach((clip) => {
                  clip.tracks = clip.tracks.filter(
                    (track) =>
                      !track.name.includes("hip.quaternion") &&
                      !track.name.includes(".scale") &&
                      !track.name.includes(".position") &&
                      !track.name.includes(".visible")
                  );
                  const action = mixer.clipAction(clip);
                  actions[clip.name] = action;
                });

                bikerModel = object;

                const rootBone = object.getObjectByName("hip");
                if (rootBone) rootBone.rotation.z = 0.04;

                skeletonHelper = new THREE.SkeletonHelper(object);
                skeletonHelper.visible = false;
                scene.add(skeletonHelper);

                const shape = new CANNON.Sphere(0.5);
                bikerBody = new CANNON.Body({
                  mass: 1,
                  shape,
                  position: new CANNON.Vec3(position.x, position.y, position.z),
                });
                physicsWorld.addBody(bikerBody);
              }

              if (options.hasPhysics) {
                object.traverse((child) => {
                  if (child.isMesh) {
                    const geometry = child.geometry.clone();
                    geometry.applyMatrix4(child.matrixWorld);

                    geometry.translate(0, floorY, 0);

                    const shape = createTrimesh(geometry);
                    if (shape) {
                      const body = new CANNON.Body({
                        mass: 0,
                        shape,
                        position: new CANNON.Vec3(0, 0, 0),
                      });

                      physicsWorld.addBody(body);

                      const wireframeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff0000,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.3,
                      });

                      collisionHelper = new THREE.Mesh(geometry, wireframeMaterial);
                      collisionHelper.visible = false;
                      scene.add(collisionHelper);
                    } else {
                      console.warn("Trimesh inválido em:", child.name);
                    }
                  }
                });
              }

              resolve(object);
            },
            undefined,
            (error) => {
              console.error("Erro ao carregar modelo:", error);
              reject(error);
            }
          );
        });
      }

      // === MODELOS ===
      loadModel(
        "resources/models/Jo on Bike.fbx",
        { x: -17, y: 0, z: 0 },
        { x: 0, y: -Math.PI / 2, z: 0 },
        { x: 1, y: 1, z: 1 },
        { isCharacter: true }
      );

      loadModel(
        "resources/models/cartoon_race_track_spielberg.glb",
        { x: 0, y: floorY, z: 0 },
        { x: 0, y: 0, z: 0 },
        { x: 1, y: 1, z: 1 },
        { hasPhysics: true }
      );

      // === CONTROLE DO PERSONAGEM ===
      window.addEventListener("keydown", (event) => {
        keys[event.key.toLowerCase()] = true;
      });

      window.addEventListener("keyup", (event) => {
        keys[event.key.toLowerCase()] = false;
      });

      // === GUI ===
      createPanel();
      camera.position.set(0, 100, 0);

      let lastDirection;

      // === LOOP DE ANIMAÇÃO ===
      function loop() {
        const delta = clock.getDelta();

        physicsWorld.step(1 / 60, delta);

        if (bikerModel && bikerBody) {
          const direction = new CANNON.Vec3();

          if (keys["w"]) {
            direction.z = 1;
            if (lastDirection == -1 && moveSpeed > 0) {
              moveSpeed -= braking;
              direction.z = -1;
            } else {
              if (moveSpeed <= maxSpeed) moveSpeed += acceleration;
            }
            playAnimation("M_rig_Action_S");
            if (activeAction) activeAction.timeScale = moveSpeed / 8;
          } else if (keys["s"]) {
            direction.z = -1;
            if (lastDirection == 1 && moveSpeed > 0) {
              moveSpeed -= braking;
              direction.z = 1;
            } else {
              if (moveSpeed <= maxSpeed) moveSpeed += acceleration;
            }

            playAnimation("M_rig_Action_S");
            if (activeAction) activeAction.timeScale = -moveSpeed / 8;
          } else {
            if (moveSpeed > 0) {
              moveSpeed = moveSpeed -= acceleration;
              direction.z = lastDirection;
            }
            stopCurrentAnimation();
          }

          lastDirection = direction.z;

          if (keys["a"]) bikerModel.rotation.y += 0.05;
          if (keys["d"]) bikerModel.rotation.y -= 0.05;

          direction.normalize();
          const angle = bikerModel.rotation.y;
          const sin = Math.sin(angle),
            cos = Math.cos(angle);

          const forward = new CANNON.Vec3(direction.z * sin, 0, direction.z * cos);
          forward.scale(moveSpeed, forward);

          bikerBody.velocity.x = forward.x;
          bikerBody.velocity.z = forward.z;

          bikerModel.position.lerpVectors(bikerModel.position, bikerBody.position, 0.2);
        }

        if (mixer) mixer.update(delta);

        if (bikerModel) {
          const offset = new THREE.Vector3(0, 2, -4);
          const cameraOffset = offset.clone().applyQuaternion(bikerModel.quaternion).add(bikerModel.position);
          camera.position.lerp(cameraOffset, 0.2);
          camera.lookAt(bikerModel.position.clone().add(new THREE.Vector3(0, 1, 0)));
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
